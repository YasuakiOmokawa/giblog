.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Giblog::API 3"
.TH Giblog::API 3 "2019-03-23" "perl v5.20.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Giblog::API \- Giblog API
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Giblog::API defines sevral methods to manipulate \s-1HTML\s0 contents.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 1
\&  my $api = Giblog::API\->new(%params);
.Ve
.PP
Create Giblog::API object.
.PP
\&\fBParameters:\fR
.IP "\(bu" 4
giblog
.Sp
Set Giblog object.
.Sp
By \f(CW\*(C`giblog\*(C'\fR method, you can access this parameter.
.Sp
.Vb 1
\&  my $giblog = $api\->giblog;
.Ve
.SS "giblog"
.IX Subsection "giblog"
.Vb 1
\&  my $giblog = $api\->giblog;
.Ve
.PP
Get Giblog object.
.SS "config"
.IX Subsection "config"
.Vb 1
\&  my $config = $api\->config;
.Ve
.PP
Get Giblog config. This is hash reference.
.PP
Config is loaded by \f(CW\*(C`read_config\*(C'\fR method.
.PP
If config is not loaded, this method return undef.
.SS "home_dir"
.IX Subsection "home_dir"
.Vb 1
\&  my $home_dir = $api\->home_dir;
.Ve
.PP
Get home directory.
.SS "read_config"
.IX Subsection "read_config"
.Vb 1
\&  my $config = $api\->read_config;
.Ve
.PP
Parse \*(L"giblog.conf\*(R" in home directory and return hash reference.
.PP
\&\*(L"giblog.conf\*(R" must end with correct hash reference. Otherwise exception occur.
.PP
.Vb 5
\&  # giblog.conf
\&  {
\&    site_title => \*(Aqmysite\*(Aq,
\&    site_url => \*(Aqhttp://somesite.example\*(Aq,
\&  }
.Ve
.PP
After calling \*(L"read_config\*(R", You can also get config by \f(CW\*(C`config\*(C'\fR method.
.SS "clear_config"
.IX Subsection "clear_config"
.Vb 1
\&  $api\->clear_config;
.Ve
.PP
Clear config. Set undef to config.
.SS "create_dir"
.IX Subsection "create_dir"
.Vb 1
\&  $api\->create_dir($dir);
.Ve
.PP
Create directory.
.PP
If Creating directory fail, exception occur.
.SS "create_file"
.IX Subsection "create_file"
.Vb 1
\&  $api\->create_file($file);
.Ve
.PP
Create file.
.PP
If Creating file fail, exception occur.
.SS "write_to_file"
.IX Subsection "write_to_file"
.Vb 1
\&  $api\->write_to_file($file, $content);
.Ve
.PP
Write content to file. Content is encoded to \s-1UTF\-8.\s0
.PP
If file is not exists, file is created automatically.
.PP
If Creating file fail, exception occur.
.SS "slurp_file"
.IX Subsection "slurp_file"
.Vb 1
\&  my $content = $api\->slurp_file($file);
.Ve
.PP
Get file content. Content is decoded from \s-1UTF\-8.\s0
.PP
If file is not exists, exception occur.
.SS "rel_file"
.IX Subsection "rel_file"
.Vb 1
\&  my $file = $api\->rel_file(\*(Aqfoo/bar\*(Aq);
.Ve
.PP
Get combined path of home directory and specific relative path.
.PP
If home directory is not set, return specific path.
.SS "create_website_from_proto"
.IX Subsection "create_website_from_proto"
.Vb 1
\&  $api\->create_website_from_proto($home_dir, $module_name);
.Ve
.PP
Create website home directory and copy files from prototype directory.
.PP
Prototype directory is automatically detected from module name.
.PP
If module name is \*(L"Giblog::Command::new_foo\*(R" and the loading path is \*(L"lib/Giblog/Command/new_foo.pm\*(R", path of prototype directory is \*(L"lib/Giblog/Command/new_foo/proto\*(R".
.PP
.Vb 2
\&  lib/Giblog/Command/new_foo.pm
\&                    /new_foo/proto
.Ve
.PP
Module must be loaded before calling \*(L"create_website_from_proto\*(R". otherwise exception occur.
.PP
If home directory is not specific, exception occur.
.PP
If home directory already exists, exception occur.
.PP
If creating directory fail, exception occur.
.PP
If proto directory corresponding to module name is not specific, exception occur.
.PP
If proto direcotry corresponding to module name is not found, exception occur.
.SS "get_templates_files"
.IX Subsection "get_templates_files"
.Vb 1
\&  $api\->get_templates_files;
.Ve
.PP
Get file names in \*(L"templates\*(R" directory in home directory.
.PP
Files in \*(L"templates/common\*(R" directory and hidden files(which start with \*(L".\*(R") is not contained.
.PP
Got file name is relative name from \*(L"templates\*(R" directory.
.PP
For example,
.PP
.Vb 3
\&  index.html
\&  blog/20190312121345.html
\&  blog/20190314452341.html
.Ve
.SS "get_content"
.IX Subsection "get_content"
.Vb 1
\&  $api\->get_content($data);
.Ve
.PP
Get content from relative file name from \*(L"templates\*(R" directory. Content is decoded from \s-1UTF\-8.\s0
.PP
\&\fB\s-1INPUT:\s0\fR
.PP
.Vb 1
\&  $data\->{file}
.Ve
.PP
\&\fB\s-1OUTPUT:\s0\fR
.PP
.Vb 1
\&  $data\->{content}
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 4
\&  # Get content from templates/index.html
\&  $data\->{file} = \*(Aqindex.html\*(Aq;
\&  $api\->get_content($data);
\&  my $content = $data\->{content};
.Ve
.SS "parse_giblog_syntax"
.IX Subsection "parse_giblog_syntax"
.Vb 1
\&  $api\->parse_giblog_syntax($data);
.Ve
.PP
Parse input text as \*(L"Giblog syntax\*(R", and return output.
.PP
\&\fB\s-1INPUT:\s0\fR
.PP
.Vb 1
\&  $data\->{content}
.Ve
.PP
\&\fB\s-1OUTPUT:\s0\fR
.PP
.Vb 1
\&  $data\->{content}
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&  # Parse input as giblog syntax
\&  $data\->{content} = <<\*(AqEOS\*(Aq;
\&  Hello World!
\&
\&  <b>Hi, Yuki</b>
\&
\&  <div>
\&    OK
\&  </div>
\&
\&  <pre>
\&  my $foo = 1 > 3 && 2 < 5;
\&  </pre>
\&  EOS
\&  
\&  $api\->parse_giblog_syntax($data);
\&  my $content = $data\->{content};
.Ve
.PP
\&\fBGiblog syntax\fR
.PP
Giblog syntax is simple syntax to write content easily.
.IP "1. Add p tag automatically" 4
.IX Item "1. Add p tag automatically"
Add p tag to inline element starting from the beginning of line.
.Sp
.Vb 2
\&  # Input
\&  Hello World!
\&  
\&  <b>Hi, Yuki</b>
\&  
\&  <div>
\&    OK
\&  </div>
\&  
\&  # Output
\&  <p>
\&    Hello World!
\&  </p>
\&  <p>
\&    <b>Hi, Yuki</b>
\&  </p>
\&  <div>
\&    OK
\&  </div>
.Ve
.Sp
Empty line is deleted.
.IP "2. Escape >, < in pre tag" 4
.IX Item "2. Escape >, < in pre tag"
If pre tag starts at the beginning of the line and its end tag starts at the beginning of the line, execute \s-1HTML\s0 escapes \*(L">\*(R" and \*(L"<\*(R" between them.
.Sp
.Vb 4
\&  # Input
\&  <pre>
\&  my $foo = 1 > 3 && 2 < 5;
\&  </pre>
\&
\&  # Output
\&  <pre>
\&  my $foo = 1 &gt; 3 && 2 &lt; 5;
\&  </pre>
.Ve
.SS "parse_title"
.IX Subsection "parse_title"
.Vb 1
\&  $api\->parse_title($data);
.Ve
.PP
Get title from text of tag which class name is \*(L"title\*(R".
.PP
If parser can't get title, title become undef.
.PP
\&\fB\s-1INPUT:\s0\fR
.PP
.Vb 1
\&  $data\->{content}
.Ve
.PP
\&\fB\s-1OUTPUT:\s0\fR
.PP
.Vb 1
\&  $data\->{title}
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 6
\&  # Get title
\&  $data\->{content} = <<\*(AqEOS\*(Aq;
\&  <div class="title">Perl Tutorial</div>
\&  EOS
\&  $api\->parse_title($data);
\&  my $title = $data\->{title};
.Ve
.SS "parse_title_from_first_h_tag"
.IX Subsection "parse_title_from_first_h_tag"
.Vb 1
\&  $api\->parse_title_from_first_h_tag($data);
.Ve
.PP
Get title from text of first h1, h2, h3, h4, h5, h6 tag.
.PP
If parser can't get title, title become undef.
.PP
\&\fB\s-1INPUT:\s0\fR
.PP
.Vb 1
\&  $data\->{content}
.Ve
.PP
\&\fB\s-1OUTPUT:\s0\fR
.PP
.Vb 1
\&  $data\->{title}
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 6
\&  # Get title
\&  $data\->{content} = <<\*(AqEOS\*(Aq;
\&  <h1>Perl Tutorial</h1>
\&  EOS
\&  $api\->parse_title_from_first_h_tag($data);
\&  my $title = $data\->{title};
.Ve
.SS "add_page_link"
.IX Subsection "add_page_link"
.Vb 2
\&  $api\->add_page_link($data);
\&  $api\->add_page_link($data, $opt);
.Ve
.PP
Add page link to text of tag which class name is \*(L"title\*(R".
.PP
If parser can't get title, content is not changed.
.PP
\&\fB\s-1INPUT:\s0\fR
.PP
.Vb 2
\&  $data\->{file}
\&  $data\->{content}
.Ve
.PP
\&\fB\s-1OUTPUT:\s0\fR
.PP
.Vb 1
\&  $data\->{content}
.Ve
.PP
\&\*(L"file\*(R" is relative path from \*(L"templates\*(R" directory.
.PP
If added link is the path which combine \*(L"/\*(R" and value of \*(L"file\*(R".
.PP
if \f(CW$opt\fR\->{root} is specifed and this match \f(CW$data\fR\->{file}, added link is \*(L"/\*(R".
.PP
\&\fBExample:\fR
.PP
.Vb 7
\&  # Add page link
\&  $data\->{file} = \*(Aqblog/20181012123456.html\*(Aq;
\&  $data\->{content} = <<\*(AqEOS\*(Aq;
\&  <div class="title">Perl Tutorial</div>
\&  EOS
\&  $api\->add_page_link($data);
\&  my $content = $data\->{content};
.Ve
.PP
Content is changed to
.PP
.Vb 1
\&  <div class="title"><a href="/blog/20181012123456.html">Perl Tutorial</a></div>
.Ve
.PP
\&\fBExample: root page\fR
.PP
.Vb 7
\&  # Add page link
\&  $data\->{file} = \*(Aqindex.html\*(Aq;
\&  $data\->{content} = <<\*(AqEOS\*(Aq;
\&  <div class="title">Perl Tutorial</div>
\&  EOS
\&  $api\->add_page_link($data);
\&  my $content = $data\->{content};
.Ve
.PP
Content is changed to
.PP
.Vb 1
\&  <div class="title"><a href="/">Perl Tutorial</a></div>
.Ve
.SS "add_page_link_to_first_h_tag"
.IX Subsection "add_page_link_to_first_h_tag"
.Vb 2
\&  $api\->add_page_link_to_first_h_tag($data);
\&  $api\->add_page_link_to_first_h_tag($data, $opt);
.Ve
.PP
Add page link to text of first h1, h2, h3, h4, h5, h6 tag.
.PP
If parser can't get title, content is not changed.
.PP
\&\fB\s-1INPUT:\s0\fR
.PP
.Vb 2
\&  $data\->{file}
\&  $data\->{content}
.Ve
.PP
\&\fB\s-1OUTPUT:\s0\fR
.PP
.Vb 1
\&  $data\->{content}
.Ve
.PP
\&\*(L"file\*(R" is relative path from \*(L"templates\*(R" directory.
.PP
If added link is the path which combine \*(L"/\*(R" and value of \*(L"file\*(R".
.PP
if \f(CW$opt\fR\->{root} is specifed and this match \f(CW$data\fR\->{file}, added link is \*(L"/\*(R".
.PP
\&\fBExample: entry page\fR
.PP
.Vb 7
\&  # Add page link
\&  $data\->{file} = \*(Aqblog/20181012123456.html\*(Aq;
\&  $data\->{content} = <<\*(AqEOS\*(Aq;
\&  <h1>Perl Tutorial</h1>
\&  EOS
\&  $api\->add_page_link_to_first_h_tag($data);
\&  my $content = $data\->{content};
.Ve
.PP
Content is changed to
.PP
.Vb 1
\&  <h1><a href="/blog/20181012123456.html">Perl Tutorial</a></h1>
.Ve
.PP
\&\fBExample: root\fR
.PP
.Vb 7
\&  # Add page link
\&  $data\->{file} = \*(Aqindex.html\*(Aq;
\&  $data\->{content} = <<\*(AqEOS\*(Aq;
\&  <h1>Perl Tutorial</h1>
\&  EOS
\&  $api\->add_page_link_to_first_h_tag($data);
\&  my $content = $data\->{content};
.Ve
.PP
Content is changed to
.PP
.Vb 1
\&  <h1><a href="/">Perl Tutorial</a></h1>
.Ve
.SS "parse_description"
.IX Subsection "parse_description"
.Vb 1
\&  $api\->parse_description($data);
.Ve
.PP
Get description from text of tag which class name is \*(L"description\*(R".
.PP
Both of left spaces and right spaces are removed. This is Unicode space.
.PP
If parser can't get description, description become undef.
.PP
\&\fB\s-1INPUT:\s0\fR
.PP
.Vb 1
\&  $data\->{content}
.Ve
.PP
\&\fB\s-1OUTPUT:\s0\fR
.PP
.Vb 1
\&  $data\->{description}
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 8
\&  # Get description
\&  $data\->{content} = <<\*(AqEOS\*(Aq;
\&  <div class="description">
\&    Perl Tutorial is site for beginners of Perl 
\&  </div>
\&  EOS
\&  $api\->parse_description($data);
\&  my $description = $data\->{description};
.Ve
.PP
Output description is \*(L"Perl Tutorial is site for beginners of Perl\*(R".
.SS "parse_description_from_first_p_tag"
.IX Subsection "parse_description_from_first_p_tag"
.Vb 1
\&  $api\->parse_description_from_first_p_tag($data);
.Ve
.PP
Get description from text of first p tag.
.PP
\&\s-1HTML\s0 tag is removed.
.PP
Both of left spaces and right spaces is removed. This is Unicode space.
.PP
If parser can't get description, description become undef.
.PP
\&\fB\s-1INPUT:\s0\fR
.PP
.Vb 1
\&  $data\->{content}
.Ve
.PP
\&\fB\s-1OUTPUT:\s0\fR
.PP
.Vb 1
\&  $data\->{description}
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 11
\&  # Get description
\&  $data\->{content} = <<\*(AqEOS\*(Aq;
\&  <p>
\&    Perl Tutorial is site for beginners of Perl 
\&  </p>
\&  <p>
\&    Foo, Bar
\&  </p>
\&  EOS
\&  $api\->parse_description_from_first_p_tag($data);
\&  my $description = $data\->{description};
.Ve
.PP
Output description is \*(L"Perl Tutorial is site for beginners of Perl\*(R".
.SS "parse_keywords"
.IX Subsection "parse_keywords"
.Vb 1
\&  $api\->parse_keywords($data);
.Ve
.PP
Get keywords from text of tag which class name is \*(L"keywords\*(R".
.PP
If parser can't get keywords, keywords become undef.
.PP
\&\fB\s-1INPUT:\s0\fR
.PP
.Vb 1
\&  $data\->{content}
.Ve
.PP
\&\fB\s-1OUTPUT:\s0\fR
.PP
.Vb 1
\&  $data\->{keywords}
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 6
\&  # Get keywords
\&  $data\->{content} = <<\*(AqEOS\*(Aq;
\&  <div class="keywords">Perl,Tutorial</div>
\&  EOS
\&  $api\->parse_keywords($data);
\&  my $keywords = $data\->{keywords};
.Ve
.SS "parse_first_img_src"
.IX Subsection "parse_first_img_src"
.Vb 1
\&  $api\->parse_first_img_src($data);
.Ve
.PP
Get image src from src attribute of first img tag.
.PP
If parser can't get image src, image src become undef.
.PP
\&\fB\s-1INPUT:\s0\fR
.PP
.Vb 1
\&  $data\->{content}
.Ve
.PP
\&\fB\s-1OUTPUT:\s0\fR
.PP
.Vb 1
\&  $data\->{img_src}
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 6
\&  # Get first_img_src
\&  $data\->{content} = <<\*(AqEOS\*(Aq;
\&<img class="ppp" src="/path">
\&  EOS
\&  $api\->parse_first_img_src($data);
\&  my $img_src = $data\->{img_src};
.Ve
.PP
Output img_src is \*(L"/path\*(R".
.SS "read_common_templates"
.IX Subsection "read_common_templates"
.Vb 1
\&  $api\->read_common_templates($data);
.Ve
.PP
Read common templates in \*(L"templates/common\*(R" directory.
.PP
The follwoing templates is loaded. Content is decoded from \s-1UTF\-8.\s0
.PP
\&\*(L"meta.html\*(R", \*(L"header.html\*(R", \*(L"footer.html\*(R", \*(L"side.html\*(R", \*(L"top.html\*(R", \*(L"bottom.html\*(R"
.PP
\&\fB\s-1OUTPUT:\s0\fR
.PP
.Vb 6
\&  $data\->{meta}
\&  $data\->{header}
\&  $data\->{footer}
\&  $data\->{side}
\&  $data\->{top}
\&  $data\->{bottom}
.Ve
.SS "add_meta_title"
.IX Subsection "add_meta_title"
Add title tag to meta section.
.PP
\&\fB\s-1INPUT:\s0\fR
.PP
.Vb 2
\&  $data\->{title}
\&  $data\->{meta}
.Ve
.PP
\&\fB\s-1OUTPUT:\s0\fR
.PP
.Vb 1
\&  $data\->{meta}
.Ve
.PP
If value of \*(L"meta\*(R" is \*(L"foo\*(R" and \*(L"title\*(R" is \*(L"Perl Tutorial\*(R", output value of \*(L"meta\*(R" become \*(L"foo\en<title>Perl Tutorial</title>\*(R"
.SS "add_meta_description"
.IX Subsection "add_meta_description"
Add meta description tag to meta section.
.PP
\&\fB\s-1INPUT:\s0\fR
.PP
.Vb 2
\&  $data\->{description}
\&  $data\->{meta}
.Ve
.PP
\&\fB\s-1OUTPUT:\s0\fR
.PP
.Vb 1
\&  $data\->{meta}
.Ve
.PP
If value of \*(L"meta\*(R" is \*(L"foo\*(R" and \*(L"description\*(R" is \*(L"Perl is good\*(R", output value of \*(L"meta\*(R" become \*(L"foo\en<meta name=\*(R"description\*(L" content=\*(R"Perl is good\*(L">\*(R"
.SS "build_entry"
.IX Subsection "build_entry"
Build entry \s-1HTML\s0 by \*(L"content\*(R" and \*(L"top\*(R", \*(L"bottom\*(R".
.PP
\&\fB\s-1INPUT:\s0\fR
.PP
.Vb 3
\&  $data\->{content}
\&  $data\->{top}
\&  $data\->{bottom}
.Ve
.PP
\&\fB\s-1OUTPUT:\s0\fR
.PP
.Vb 1
\&  $data\->{content}
.Ve
.PP
Output is the following \s-1HTML.\s0
.PP
.Vb 11
\&  <div class="entry">
\&    <div class="top">
\&      $data\->{top}
\&    </div>
\&    <div class="middle">
\&      $data\->{content}
\&    </div>
\&    <div class="bottom">
\&      $data\->{bottom}
\&    </div>
\&  </div>
.Ve
.SS "build_html"
.IX Subsection "build_html"
Build whole \s-1HTML\s0 by \*(L"content\*(R" and \*(L"header\*(R", \*(L"bottom\*(R", \*(L"side\*(R", \*(L"footer\*(R".
.PP
\&\fB\s-1INPUT:\s0\fR
.PP
.Vb 5
\&  $data\->{content}
\&  $data\->{header}
\&  $data\->{bottom}
\&  $data\->{side}
\&  $data\->{footer}
.Ve
.PP
\&\fB\s-1OUTPUT:\s0\fR
.PP
.Vb 1
\&  $data\->{content}
.Ve
.PP
Output is the following \s-1HTML.\s0
.PP
.Vb 10
\&  <!DOCTYPE html>
\&  <html>
\&    <head>
\&      $data\->{meta}
\&    </head>
\&    <body>
\&      <div class="container">
\&        <div class="header">
\&          $data\->{header}
\&        </div>
\&        <div class="main">
\&          <div class="content">
\&            $data\->{content}
\&          </div>
\&          <div class="side">
\&            $data\->{side}
\&          </div>
\&        </div>
\&        <div class="footer">
\&          $data\->{footer}
\&        </div>
\&      </div>
\&    </body>
\&  </html>
.Ve
.SS "write_to_public_file"
.IX Subsection "write_to_public_file"
Write content to file in \*(L"public\*(R" directory. Content is encoded to \s-1UTF\-8.\s0
.PP
If value of \*(L"file\*(R" is \*(L"index.html\*(R", write path become \*(L"public/index.html\*(R"
.PP
\&\fB\s-1INPUT:\s0\fR
.PP
.Vb 2
\&  $data\->{content}
\&  $data\->{file}
.Ve
